// Generated by CoffeeScript 1.9.2

/*
  Tweak.js 1.7.10

  (c) 2014 Blake Newman.
  TweakJS may be freely distributed under the MIT license.
  For all details and documentation:
  http://tweakjs.com
 */


/*
  Tweak.js can be accessed globaly by tweak or Tweak. If using in node or a CommonJs then Tweak.js is not global.

  @note Assign ($, jQuery, Zepto...) to Tweak.$ for internal use. By default it will try to auto detect a value to use.
  This value can be overriden at any point.
  
  @note Assign module loader's require method to Tweak.require. By default it will try to auto detect a value to use; 
  depending on the enviroment and module loader used you may need to overwrite this value.
  
  @note Assign true to Tweak.strict when you wish all components to require a related config module. By default this
  module does not need to exist however  it is recommended as it allows powerful auto generation of components and deep
  extensions.

  Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
  is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
  understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
  community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
 */

(function() {
  var $, Tweak, root, tweak,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Tweak = (function() {

    /*
      This constructs Tweak with default properties. Tweak is automatically assigned to Tweak, tweak and module.exports.
     */
    function Tweak(root1, tweak, require1, $1) {
      this.root = root1;
      this.require = require1;
      this.$ = $1;
      this.prevTweak = this.root.tweak || tweak;
    }


    /*
      To extend an object with JS use Tweak.extends().
      @note This is documented as a variable but is actually a method.
      @param [Object] child The child Object to extend.
      @param [Object] parent The parent Object to inheret methods.
     */

    Tweak.prototype["extends"] = extend;


    /*
      Bind a context to a method. For example with 'that' being a different context Tweak.bind(this.pullyMethod, that).
      @note This is documented as a variable but is actually a method.
      @param [Function] fn The function to bind a property to.
      @param [Context] context The context to bing to a function.
     */

    Tweak.prototype.bind = bind;


    /*
      To super a method with JS use Tweak.super(context);. Alternativaly just do (example) Model.__super__.set(this);
      @param [Object] context The context to apply a super call to.
      @param [string] name The method name to call super upon.
      @param [Obect] that Pass a context to the super call.
     */

    Tweak.prototype["super"] = function(context, name, that) {
      return context.__super__[name].call(that);
    };


    /*
      Restore the previous stored Tweak/tweak.
     */

    Tweak.prototype.noConflict = function() {
      var tweak;
      if (pTweak) {
        tweak = Tweak = this.pTweak;
      }
      return this;
    };


    /*
      Clone a simple Object to remove reference to original Object or simply to copy it.
      @param [Object, Array] ref Reference Object to clone.
      @return [Object, Array] Returns the copied Object, while removing references.
      @throw An error will be thrown if an object type is not supported.
    
      @example Cloning an Object.
        var obj, obj2;
        obj = {
          test:'test',
          total:4
        }
        
        // Clone the object.
        obj2 = Tweak.Clone(obj);
        
        // Alter the new object without adjusting other Object.
        obj2.test = null
     */

    Tweak.prototype.clone = function(obj, parent) {
      var _new, flags, key;
      if ((obj == null) || typeof obj !== 'object' || obj === parent) {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof RegExp) {
        flags = '';
        if (obj.global != null) {
          flags += 'g';
        }
        if (obj.ignoreCase != null) {
          flags += 'i';
        }
        if (obj.multiline != null) {
          flags += 'm';
        }
        if (obj.sticky != null) {
          flags += 'y';
        }
        return new RegExp(obj.source, flags);
      }
      _new = obj instanceof Array ? [] : {};
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          _new[key] = this.clone(obj[key], obj);
        }
      }
      return _new;
    };


    /*
      Similar to Tweak.extends. However this will combine nested objects to make a full cobined object. This should only
      be done with simple objects; as this method can get very expensive.
      @param [Object, Array] ref Reference Object.
      @param [Object, Array] ref Object to merge into.
      @return [Object, Array] Returns the combined Object.
    
      @example Combining an Object.
        var obj, obj2;
        obj = {
          total:{
            laps:10,
            miles:30
          }
        }
    
        obj2 = {
          total:{
            miles:32
          }
        }
        
        // Clone the object.
        Tweak.Combine(obj);
     */

    Tweak.prototype.combine = function(obj, parent) {
      var key, prop;
      for (key in parent) {
        prop = parent[key];
        if (typeof prop === 'object') {
          if (obj[key] == null) {
            obj[key] = prop instanceof Array ? [] : {};
          }
          obj[key] = this.combine(obj[key], prop);
        } else {
          obj[key] = prop;
        }
      }
      return obj;
    };


    /*
      Switch a JSONObject/JSONString to it alternative type.
      @param [JSONString, JSONObject] data JSONString/JSONObject to convert to vice versa.
      @return [JSONObject, JSONString] Returns JSONString/JSONObject data of the alternative type of passed value
    
      @example JSON conversions.
        var jString, jObj;
    
        jString = '{"cats":"meow"}';
        jObj = {
          dogs:'woof'
        }
    
        Tweak.JSON(jString);
        // Returns Object - { "cats":"meow" }
    
        Tweak.JSON(jObj);
        // Returns String - "{"dogs":"woof"}"
     */

    Tweak.prototype.JSON = function(data) {
      return JSON[typeof data === 'string' ? 'parse' : 'stringify'](data);
    };


    /*
      Try to find a module by name from multiple paths returning the first found module. A final surrogate will be
      returned if no modules could be found.
      @param [Array<String>] paths An array of context paths.
      @param [String] module The module path to convert to absolute path; based on the context path.
      @param [Object] surrogate (Optional) A surrogate Object that can be used if there is no module found.
      @return [Object] Returns an Object that has the highest priority.
      @throw When a module is not found and there is no surrogate an error will be thrown -
        "No module #{module name} for #{component name}".
      @throw An error will be thrown if an object is found but an error occured during processing
    
      @example Request 'template' module from contexts of ['app/index', 'components/page']
        Tweak.request(['app/index', 'components/page'], './template');
        // Returns template module if found in any of the contexts or throws error
    
      @example Request 'template' module from contexts of ['app/index', 'components/page'], if not found a surrogate is used
        var sur;
        sur = {
          body:'<body></body>'
        }
        Tweak.request(['app/index', 'components/page'], './template', surr);
        // Returns template module if found or returns the surrogate
     */

    Tweak.prototype.findModule = function(contexts, module, surrogate) {
      var context, e, j, len;
      for (j = 0, len = contexts.length; j < len; j++) {
        context = contexts[j];
        try {
          return this.request(context, module);
        } catch (_error) {
          e = _error;
          if (e.name !== 'Error') {
            throw e;
          }
        }
      }
      if (surrogate != null) {
        return surrogate;
      }
      throw new Error("No module " + module + " for " + contexts[0]);
    };


    /*
      Require/request a module from given context and path or return a surrogate.
      @param [String] context The context path.
      @param [String] module The module path to convert to absolute path, based on the context path.
      @param [Object] surrogate (Optional) A surrogate Object that can be used if there is no module found.
      @return [Object] Required/requested module or the surrogate if requested.
      @throw Error upon no found module.
    
      @example Request 'template' module from 'app/index'
        Tweak.request('app/index', './template');
        // Returns template module if found or throws error
    
      @example Request 'template' module from 'app/index', if not found a surrogate is used
        var sur;
        sur = {
          body:'<body></body>'
        }
        Tweak.request('app/index', './template', sur);
        // Returns template module if found or returns the surrogate
     */

    Tweak.prototype.request = function(context, module, surrogate) {
      var e, path;
      path = this.toAbsolute(context, module);
      try {
        return this.require(path);
      } catch (_error) {
        e = _error;
        if (surrogate != null) {
          return surrogate;
        }
        throw e;
      }
    };


    /*
      Split a path formated as a 'multi-path' into individual paths.
      @param [Array<String>, String] paths 'multi-path's to format.
      @return [Array<String>] Array of paths.
    
      @example Names formated as './cd[2-4]'
        Tweak.splitPaths('./cd[2-4]');
        // Returns ['./cd2','./cd3','./cd4']
    
      @example Names formated as ['./cd[2]/model', '../what1']
        Tweak.splitPaths(['./cd[2]', '../what1']);
        // Returns ['./item0/model','./item1/model','./item2/model', '../what1']
    
      @example Names formated as single space delimited String './cd[2]/model ../what1'
        Tweak.splitPaths('./cd[2]/model ../what1');
        // Returns ['./item0/model','./item1/model','./item2/model', '../what1']
     */

    Tweak.prototype.splitPaths = function(paths) {
      var j, k, len, match, max, min, num, path, prefix, ref, ref1, reg, results, suffix;
      reg = /^(.*)\[(\d*)(?:[,\-](\d*)){0,1}\](.*)$/;
      if (typeof paths === 'string') {
        paths = paths.split(/\s+/);
      }
      results = [];
      for (j = 0, len = paths.length; j < len; j++) {
        path = paths[j];
        match = reg.exec(path);
        if (match != null) {
          prefix = match[0], min = match[1], max = match[2], suffix = match[3];
          for (num = k = ref = min || 0, ref1 = max || min; ref <= ref1 ? k <= ref1 : k >= ref1; num = ref <= ref1 ? ++k : --k) {
            results.push("" + prefix + num + suffix);
          }
        } else {
          results.push(path);
        }
      }
      return results;
    };


    /*
      Convert a relative path to an absolute path; relative path defined by ./ or .\ It will also
      navigate up per defined ../.
      @param [String] context The path to navigate to find absolute path based on given relative path.
      @param [String] relative The relative path to convert to absolute path.
      @return [String] Absolute path based upon the given context and relative path.
    
    
      @example Create absolute path from context of "albums/cds/songs"  with a path of '../cd1'
        Tweak.toAbsolute('albums/cds/songs', '../cd1');
        // Returns 'albums/cds/cd1'
    
      @example Create absolute path from context of "album1/cd1"  with a path of './beautiful'
        Tweak.toAbsolute('album1/cd1', './beautiful');
        // Returns 'album1/cd1/beautiful'
     */

    Tweak.prototype.toAbsolute = function(context, relative) {
      var affixReg, amount, reduceReg, upReg;
      affixReg = /^(\.+[\/\\]*)+/;
      upReg = /^\.{2,}[\/\\]*/;
      amount = relative.split(upReg).length - 1 || 0;
      reduceReg = RegExp("([\\/\\\\]*[^\\/\\\\]+){" + amount + "}[\\/\\\\]?$");
      return relative.replace(affixReg, (context.replace(reduceReg, '')) + "/");
    };

    return Tweak;

  })();


  /*
    Assign root as either self, global or window.
   */

  root = (typeof self === 'object' && self.self === self && self) || (typeof global === 'object' && global.global === global && global) || window;


  /*
    To keep alternative frameworks to jQuery available to Tweak, register/define the appropriate framework to '$'.
   */

  if (typeof define === 'function' && define.amd) {
    define(['$', 'exports'], function($, exports) {

      /*
        This will enable a switch to a CommonJS based system with AMD.
       */
      var toRequire;
      toRequire = function(module) {
        return define([module], function(res) {
          return res;
        });
      };
      return exports = Tweak = root.tweak = root.Tweak = new Tweak(root, exports, toRequire, $);
    });
  } else if (typeof exports !== 'undefined') {

    /*
      CommonJS and Node environment
     */
    try {
      $ = require('$');
    } catch (_error) {}
    if (!$) {
      try {
        $ = require('jquery');
      } catch (_error) {}
    }
    if (typeof module !== "undefined" && module !== null) {
      module.exports = tweak = Tweak = new Tweak(root, exports, require, $);
    }
  } else {

    /*
      Typical web environment - even though a module loader is required it is best to allow the user to set it up.
      Example Brunch uses CommonJS however it does not work exactly like it does in node so it goes through here.
     */
    Tweak = root.tweak = root.Tweak = new Tweak(root, {}, root.require, root.jQuery || root.Zepto || root.ender || root.$);
  }


  /*
    Tweak.js has an event system class, this provides functionality to extending classes to communicate simply and
    effectively while maintaining an organised structure to your code and applications. Each object can extend the
    Tweak.EventSystem class to inherit event functionality. Majority of Tweak.js modules/classes already extend
    the EventSystem class, however when creating custom objects/classes you can extend the class using the Tweak.extends
    method or your chosen language's extends method.
    
    The event system is bound to an object instance that extends the Tweak.Events Class. By bounding a Event system to
    an instance you keep your event structure focused and accurate; avoiding confusion with complex event scopes. Event
    names can be name spaced by any character, but you should keep the same name spacing structure as each structure will
    be treated as unique. The typical character is to use is a ':'; so an example of a event name will be 'changed:name'.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Events = (function() {
    function Events() {}


    /*
      Iterate through bound events to find matching events. The method can also be used to construct an event by passing
      an optional true value Boolean argument.
    
      @overload findEvent(names, build)
        Find events with a space separated string.
        @param [String] names The event name(s); split on a space.
        @param [Boolean] build (Default = false) Whether or not to add an event object when none can be found.
        @return [Array<Event>] All event objects that are found/created then it is returned in an Array.
    
      @overload findEvent(names, build)
        Find events with an array of names (strings).
        @param [Array<String>] names An array of names (strings).
        @param [Boolean] build (Default = false) Whether or not to add an event object when none can be found.
        @return [Array<Event>] All event objects that are found/created then it is returned in an Array.
    
      @example Delimited string
        // This will find all events in the given space delimited string.
        var model;
        model = new Model();
        model.findEvent('sample:event another:event');
    
      @example Delimited string with build
        // This will find all events in the given space delimited string.
        // If event cannot be found then it will be created.
        var model;
        model = new Model();
        model.findEvent('sample:event another:event', true);
    
      @example Array of names (strings)
        // This will find all events from the names in the given array.
        var model;
        model = new Model();
        model.findEvent(['sample:event', 'another:event']);
    
      @example Array of names (strings) with build
        // This will find all events from the names in the given array.
        // If event cannot be found then it will be created.
        var model;
        model = new Model();
        model.findEvent(['sample:event', 'another:event'], true);
     */

    Events.prototype.findEvent = function(names, build) {
      var event, events, j, len, name, results1;
      if (build == null) {
        build = false;
      }
      if (typeof names === 'string') {
        names = names.split(/\s+/);
      }
      events = this.__events = this.__events || {};
      results1 = [];
      for (j = 0, len = names.length; j < len; j++) {
        name = names[j];
        if (!(event = events[name])) {
          if (build) {
            event = this.__events[name] = {
              name: name,
              __callbacks: []
            };
          } else {
            continue;
          }
        }
        results1.push(event);
      }
      return results1;
    };


    /*
      Bind a callback to the event system. The callback is invoked when an event is triggered. Events are added to an
      object based on their name. Name spacing is useful to separate events into their relevant types. It is typical to
      use colons for name spacing, Default Tweak events will use the colon character as its name spacing. However you can
      use any other name spacing characters such as / \ - _ or . Please keep in mind that if you vary the name spacing the
      events will be treated as unique.
      
      @overload addEvent(names, callback, context, max)
        Bind a callback to event(s) with context and/or total calls
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [Function] callback The event callback function.
        @param [Object] context (optional, default = this) The contextual object of which the event to be bound to.
        @param [Number] max (optional, default = null). The maximum calls on the event listener. After the total calls
        the events callback will not invoke.
    
      @overload addEvent(names, callback, max, context)
        Bind a callback to event(s) with total calls and/or context
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [Function] callback The event callback function.
        @param [Number] max The maximum calls on the event listener. After the total calls the events callback will not invoke.
        @param [Object] context (optional, default = this) The contextual object of which the event to be bound to.
    
      @example Bind a callback to event(s)
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        });
      
      @example Bind a callback to event(s) with total calls
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        }, 4);
    
      @example Bind a callback to event(s) with a separate context without total calls
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        }, this);
    
      @example Bind a callback to event(s) with a separate context with maximum calls
        var model;
        model = new Model();
        model.addEvent('sample:event', function(){
          alert('Sample event triggered.')
        }, this, 3);
     */

    Events.prototype.addEvent = function(names, callback, context, max) {
      var event, item, j, k, len, len1, ref, ref1, ref2, toAdd;
      if (context == null) {
        context = this;
      }
      if (typeof context === 'number' || context === null) {
        ref = [context, max], max = ref[0], context = ref[1];
      }
      ref1 = this.findEvent(names, true);
      for (j = 0, len = ref1.length; j < len; j++) {
        event = ref1[j];
        toAdd = true;
        ref2 = event.__callbacks;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          item = ref2[k];
          if (item.callback === callback && context === item.context) {
            item.max = max != null ? max : item.max;
            item.calls = 0;
            item.listen = !(toAdd = false);
          }
        }
        if (toAdd) {
          event.__callbacks.push({
            context: context,
            callback: callback,
            max: max,
            calls: 0,
            listen: true
          });
        }
      }
    };


    /*
      Remove a previously bound callback function. Removing events can be limited to context and its callback. This will
      destroy references to the callback event. To stop listening to an event without removing the event use the
      updateEvent method.
    
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Function] callback (optional) The callback function of the event. If an event has a matching callback or
      callback argument is null it will be removed, however removing this event will be limited to the context argument.
      @param [Object] context (default = this) The contextual object of which the event is bound to. If an event has a
      matching context or context argument is null it will be removed, however removing this event will be limited to the
      callback argument.
    
      @example Unbind a callback from event(s)
        var model;
        model = new Model();
        model.removeEvent('sample:event another:event', @callback);
    
      @example Unbind all callbacks from event(s)
        var model;
        model = new Model();
        model.removeEvent('sample:event another:event');
     */

    Events.prototype.removeEvent = function(names, callback, context) {
      var event, item, j, key, len, ref, ref1;
      if (context == null) {
        context = this;
      }
      ref = this.findEvent(names);
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        ref1 = event.__callbacks;
        for (key in ref1) {
          item = ref1[key];
          if (((callback == null) || callback === item.callback) && ((context == null) || context === item.context)) {
            event.__callbacks.splice(key, 1);
          }
        }
        if (event.__callbacks.length === 0) {
          delete this.__events[event.name];
        }
      }
    };


    /*
      Trigger event callbacks by name. Triggers can be limited to matching context. When triggering an event you may pass
      as many arguments to the callback method.
    
      @overload triggerEvent(names, params)
        Trigger events by name only.
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [...] params Parameters to pass into the callback function.
    
      @overload triggerEvent(options, params)
        Trigger events by name and context.
        @param [Object] options Options and limiters to check against callbacks.
        @param [...] params Parameters to pass into the callback function.
        @option options [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @option options [Context] context (Default = null) The context of the callback to check against a callback.
    
      @example Triggering event(s)
        var model;
        model = new Model();
        model.triggerEvent('sample:event, another:event');
    
      @example Triggering event(s) with parameters
        var model;
        model = new Model();
        model.triggerEvent('sample:event another:event', 'whats my name', 'its...');
    
      @example Triggering event(s) but only with matching context
        var model;
        model = new Model();
        model.triggerEvent({context:@, name:'sample:event another:event'});
     */

    Events.prototype.triggerEvent = function() {
      var context, event, item, j, k, len, len1, names, params, ref, ref1, ref2;
      names = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (typeof names === 'object' && !names instanceof Array) {
        ref = names, names = ref.names, context = ref.context;
      }
      ref1 = this.findEvent(names);
      for (j = 0, len = ref1.length; j < len; j++) {
        event = ref1[j];
        ref2 = event.__callbacks;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          item = ref2[k];
          if (item.listen) {
            if ((context == null) || context === item.context) {
              if (++item.calls >= item.max && (item.max != null)) {
                item.listen = false;
              }
              setTimeout((function() {
                this.callback.apply(this.context, params);
              }).bind(item), 0);
            }
          }
        }
      }
    };


    /*
      Update an event. With this method it is possible to set the events listening state, maximum calls, and total calls
      while limiting updated events by name and optional callback and/or context.
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Object] options Optional limiters and update values.
      @option options [Object] context The contextual object to limit updating events to, this is a combined limiter, the
      value of the callback option will determine the events to update.
      @option options [Function] callback Callback function to limit updating events to, this is a combined limiter, the
      value of the context option will determine the events to update.
      @option options [Number] max Set a new maximum amount of allowed calls for an event.
      @option options [Number] calls Set the amount of calls that has been triggered on this event.
      @option options [Boolean] reset (Default = false) If true then calls on an event get set back to 0.
      @option options [Boolean] listen Whether to enable or disable listening state of an event.
    
      @example Updating event(s) to not listen
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {listen:false});
    
      @example Updating event(s) to not listen, however limited by optional context and/or callback
        // Limit events that match to a context and callback.
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {context:@, callback:@callback, listen:false});
    
        // Limit events that match to a callback.
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {callback:@anotherCallback, listen:false});
    
        // Limit events that match to a context.
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {context:@, listen:false});
    
      @example Updating event(s) maximum calls and reset its current calls
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {reset:true, max:100});
    
      @example Updating event(s) total calls
        var model;
        model = new Model();
        model.updateEvent('sample:event, another:event', {calls:29});
     */

    Events.prototype.updateEvent = function(names, options) {
      var callback, calls, context, event, item, j, k, len, len1, listen, max, ref, ref1, reset;
      if (options == null) {
        options = {};
      }
      context = options.context, max = options.max, reset = options.reset, calls = options.calls, listen = options.listen, callback = options.callback;
      if (reset) {
        calls = 0;
      }
      ref = this.findEvent(names);
      for (j = 0, len = ref.length; j < len; j++) {
        event = ref[j];
        ref1 = event.__callbacks;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          item = ref1[k];
          if (((context == null) || context !== item.context) && ((callback == null) || callback !== item.callback)) {
            if (max != null) {
              item.max = max;
            }
            if (calls != null) {
              item.calls = calls;
            }
            if (listen != null) {
              item.listen = listen;
            }
          }
        }
      }
    };


    /*
      Resets the events on this object to empty.
     */

    Events.prototype.resetEvents = function() {
      return this.__events = {};
    };

    return Events;

  })();


  /*
    This is the base Class for dynamic storage based modules. A good way to think of a Store/Model/Collection is to think
    of it as Cache; it can be used to Store data for temporary access. This data can be provided to and from a permanent
    data storage medium. A Store based Class should be used to listen to changes to data and providing actions upon the 
    triggers provided by the event system.
  
    A Store based class has a getter and setter system. So you can easily apply additional functionality when setting or 
    getting from a Store based class. 
  
    When calling the set method of a Store based class, a setter method may be called. If a setter method to the naming
    convention of 'setter_{property name}' is found then the returning value of this setter method will be assigned to
    the property being set. Setter method will have the argument of its corresponding data value that was passed in to the
    set method.
  
    When calling the get method of a Store based class, a getter method may be called. If a getter method to the naming
    convention of 'getter_{property name}' is found then the returning value of this getter will be returned by the get
    method. A getter method will have the currently stored value as its argument.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
  
    @example Creating a setter and getter in Model.
      // This example is very trivial but it illustrates some use of setters and getters
      var QuestionModel, _model, exports;
  
      module.exports = exports = QuestionModel = (function() {
        function QuestionModel() {}
  
        Tweak.extends(QuestionModel, Tweak.Model);
        
        // Correct getter will return true or false
        QuestionModel.prototype.getter_correct = function(_prev) {
          _correct = this.get('answer') === this.get('correct_answer');
          // You can use a getter to compare to the previous value
          if (_prev === true && _correct === false) {
            alert('You already got this correct, you should know the answer!'); 
          }
          // You can use the model value as a private property to later use as a comparison
          // In this instance when answer has been answered correct it will be saved to model
          if (_correct === true) {
            // Set correct silently
            this.set('correct', true, true);
          }
          return _correct
        };
  
        // The answer may only be in the range of 0 - 100
        // This setter will auto validate the answer to within the range, while if its not in range it will trigger an
        // event from the model. For example a notification could be displayed letting the user know his answer was 
        QuestionModel.prototype.setter_answer = function(value) {
          var error;
          error = value > 100 ? 'above' : value < 0 ? 'below' : null;
          if (error) {
            this.trigger('error:range:' + error, value);
          }
          if (error < 0) {
            return 0;
          } else if (value > 100) {
            return 100;
          } else {
            return value;
          }
        };
  
        return QuestionModel;
  
      })();
  
      // Create a new QuestionModel where the answer correct_answer is 10
      _model = new QuestionModel({
        correct_answer: 10
      });
      
      // Listen to answer being set alerting whether the user has got the answer correct
      _model.addEvent('changed:answer', function() {
        return alert('Answer is ' + (this.get('correct') ? 'Correct' : 'Wrong'));
      });
      
      // Listen range error - lets the user knows that his answer was above range
      _model.addEvent('error:range:above', function(value) {
        return alert('Answer (' + value + ') is above max range of 100, answer has been altered to 100');
      });
      
      // Listen range error - lets the user knows that his answer was above range
      _model.addEvent('error:range:below', function(value) {
        return alert('Answer (' + value + ') is below min range of 100, answer has been altered to 0');
      });
  
      // Alerts 'Answer is Wrong'
      _model.set('answer', 20);
  
      // Alerts 'Answer (500) is above max range of 100, answer has been altered to 100'
      // Alerts 'Answer is Wrong'
      _model.set('answer', 500);
  
      // Alerts 'Answer is Correct'
      _model.set('answer', 10);    
      
      // Alerts 'You already got this correct, you should know the answer!'
      // Alerts 'Answer is wrong'
      _model.set('answer', 5);
   */

  Tweak.Store = (function(superClass) {
    extend(Store, superClass);

    Store.prototype.__base = function() {
      return {};
    };

    Store.prototype.length = 0;


    /*
      The constructor initialises its initial data.
    
      @example Creating a Collection with predefined set of data.
        var collection;
        collection = new tweak.Collection([
          new Model(),
          new Model()
        ]);
    
      @example Creating a Model with predefined set of data
        var model;
        model = new tweak.Model({
          'demo':true,
          'example':false,
          'position':99
        });
     */

    function Store(_data1) {
      this._data = _data1 != null ? _data1 : this.__base();
    }


    /*
      Default initialiser function. By default this is empty, upon initialisation of a component this will be called.
      This acts as your constructor, giving you access to the other modules of the component. Please note you can use a
      constructor method but you will not have access to other modules.
     */

    Store.prototype.init = function() {};


    /*    
      Set a single property or multiple properties. Upon setting a property there will be an event triggered; you can use
      this to listen to changes and act upon the changes as required.     
      @overload set(data, silent)
        Set multiple properties by an object of data.
        @param [Object] data Key and property based object.
        @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes to the data.
        @param [...] params (optional) Extra parameters get passed to setter. Silent argument must be passed when this is.
      
      @overload set(name, data, silent)
        Set an individual property by the name (String) will passing extra parameters to setter
        @param [String] name The name of the property.
        @param [*] data Data to Store in the property.
        @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes to the data.
        @param [...] params (optional) Extra parameters get passed to setter. Silent argument must be passed when this is.
      
    
      @example Setting single property.
        this.set('sample', 100);
    
      @example Setting multiple properties.
        this.set({sample:100, second:2});
    
      @example Setting properties silently.
        this.set('sample', 100, true);
        this.set({sample:100, second:2}, true);
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Store has been updated.
     */

    Store.prototype.set = function(data, silent, arg3) {
      var fn, key, prev, prop;
      if (typeof data === 'string') {
        data = {}[data] = silent;
        silent = arg3;
      }
      for (key in data) {
        prop = data[key];
        prev = this._data[key];
        if (prev == null) {
          this.length++;
        }
        fn = this["setter_" + key];
        this._data[key] = fn != null ? fn(prop) : prop;
        if (!silent) {
          this.triggerEvent("changed:" + key, this._data[key]);
        }
      }
      if (!silent) {
        this.triggerEvent('changed');
      }
    };


    /*
      Returns whether two objects are the same (similar).
      @param [Object, Array] one Object to compare to Object two.
      @param [Object, Array] two Object to compare to Object one.
      @return [Boolean] Are the two Objects the same/similar?
    
      @example comparing objects.
        this.same({'sample':true},{'sample':true}); //true
        this.same({'sample':true},{'not':true}); //false
     */

    Store.prototype.same = function(one, two) {
      var key, prop;
      for (key in one) {
        prop = one[key];
        if ((two[key] == null) || prop !== two[key]) {
          return false;
        }
      }
      return true;
    };


    /*
      Get a property from the base storage.
    
      @overload get()
        Get all properties from base storage.
        @return [Array<*>, Object] Properties from base storage.
    
      @overload get(name)
        Get an individual property by a property name.
        @param [String] name The name of the property.
        @return [*] Property from base storage.
    
      @overload get(limit)
        Get multiple properties from base storage.
        @param [Array<String>] limit Array of property names to retrieve from the base storage.
        @return [Array<*>, Object] Properties from base storage.
    
      @example Get property.
        this.get('sample');
    
      @example Get mutiple properties.
        this.get(['sample', 'pizza']);
    
      @example Get all properties.
        this.get();
     */

    Store.prototype.get = function(limit) {
      var _data, base, data, fn, i, item, j, key, len;
      if (limit == null) {
        limit = (function() {
          var ref, results1;
          ref = this._data;
          results1 = [];
          for (key in ref) {
            item = ref[key];
            results1.push(key);
          }
          return results1;
        }).call(this);
      }
      if (!(limit instanceof Array)) {
        limit = [limit];
      }
      base = this.__base();
      for (i = j = 0, len = limit.length; j < len; i = ++j) {
        item = limit[i];
        fn = this["getter_" + key];
        _data = this._data[item];
        data = fn != null ? fn(_data) : _data;
        base[item] = data;
      }
      if (i <= 1) {
        base = base[item];
      }
      return base;
    };


    /*
      Checks if a property/properties exists in the base storage.
    
      @overload has(name)
        Get an individual property by a property name.
        @param [String] name The name of the property.
        @return [*] Property from base storage.
    
      @overload has(limit)
        Get multiple properties from base storage.
        @param [Array<String>] limit Array of property names to retrieve from the base storage.
        @return [Array<*>, Object] Properties from base storage.
    
      @example Get property.
        this.has('sample');
    
      @example Get mutiple properties.
        this.has(['sample', 'pizza']);
     */

    Store.prototype.has = function(limit) {
      var j, len, prop, res;
      res = this.get(limit);
      if (!(res instanceof Array)) {
        res = [res];
      }
      for (j = 0, len = res.length; j < len; j++) {
        prop = res[j];
        if (prop == null) {
          return false;
        }
      }
      return true;
    };


    /*
      Returns an array of keys where the property matches given value.
      @param [*] value Value to check.
      @return [Array<String>] Returns an array of keys where the property matches given value.
      
      @example find keys of base storage where the value matches.
        this.where(1009); //[3,87]
     */

    Store.prototype.where = function(value) {
      var key, prop, ref, results1;
      ref = this._data;
      results1 = [];
      for (key in ref) {
        prop = ref[key];
        if (prop === value) {
          results1.push(key);
        }
      }
      return results1;
    };


    /*
      Reset the base data and set length to 0 and triggers 'changed' event. 
    
      @event changed Triggers a generic event that the Store has been updated.
     */

    Store.prototype.reset = function() {
      this.length = 0;
      this._data = this.__base();
      this.triggerEvent('changed');
    };


    /*
      Import data into the Store, data can be imported silently. The import method will overwrite properties that already 
      exists; if the existing property has an import method the the data will be passed to this property' method.
    
      @param [Object, Array] data Data to import.
      @param [Boolean] silent (optional, default = true) If false events are not triggered upon any changes.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Store has been updated.
     */

    Store.prototype["import"] = function(data, silent) {
      var item, key, ref;
      if (silent == null) {
        silent = true;
      }
      for (key in data) {
        item = data[key];
        if (((ref = this._data[key]) != null ? ref["import"] : void 0) != null) {
          this._data[key]["import"](item, silent);
        } else {
          this.set(key, item, silent);
        }
      }
    };


    /*
      Export the Store's data, the data exported can be limited by an array of key names. If the existing property has an 
      export method the the data will be generated by this property' method.
    
      @param [Array<String>] limit (default = all properties) Limit which properties to convert.
      @return [Object] Store's exported data.
     */

    Store.prototype["export"] = function(limit) {
      var item, j, key, len, res;
      res = this.__base();
      if (limit == null) {
        limit = (function() {
          var ref, results1;
          ref = this._data;
          results1 = [];
          for (key in ref) {
            item = ref[key];
            results1.push(key);
          }
          return results1;
        }).call(this);
      }
      for (j = 0, len = limit.length; j < len; j++) {
        key = limit[j];
        if ((item = this.get(key)) != null) {
          if (item["export"] != null) {
            res[key] = item["export"]();
          } else {
            res[key] = item;
          }
        }
      }
      return res;
    };

    return Store;

  })(Tweak.Events);


  /*
    A Model is used by other modules like the Controller to store, retrieve and
    listen to a set of data. Tweak.js will call events through its
    **event system** when it is updated, this makes it easy to listen to updates and
    to action as and when required. The Modelâ€™s data is not a database, but a JSON
    representation of its data can be exported and imported to and from storage
    sources. In Tweak.js the Model extends the Store module - which is the core
    functionality shared between the Model and Collection. The main difference
    between a Model and collection it the base of its storage. The Model uses an
    object to store its data and a collection base storage is an Array.
    
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Model = (function(superClass) {
    extend(Model, superClass);

    function Model() {
      return Model.__super__.constructor.apply(this, arguments);
    }


    /*
      Remove a single property or many properties.
      @param [String, Array<String>] properties Array of property names to remove from a Model, or single String of the name of the property to remove.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event removed:#{key} Triggers an event based on what property has been removed.
      @event changed Triggers a generic event that the Model has been updated.
    
      @example Removing a single property.
        var model;
        model = new tweak.Model();
        model.remove('demo');
    
      @example Removing multiple properties.
        var model;
        model = new tweak.Model();
        model.remove(['demo', 'example']);
    
      @example Removing properties silently.
        var model;
        model = new tweak.Model();
        model.remove(['demo', 'example'], true);
        model.remove('position', true);
     */

    Model.prototype.remove = function(properties, silent) {
      var j, key, len, prop, property, ref;
      if (typeof properties === 'string') {
        properties = [properties];
      }
      for (j = 0, len = properties.length; j < len; j++) {
        property = properties[j];
        ref = this._data;
        for (key in ref) {
          prop = ref[key];
          if (!(key === property)) {
            continue;
          }
          this.length--;
          delete this._data[key];
          if (!silent) {
            this.triggerEvent("removed:" + key);
          }
        }
      }
      if (!silent) {
        this.triggerEvent('changed');
      }
    };


    /*
      Looks through the store for where the data matches.
      @param [*] property The property data to find a match against.
      @return [Array] Returns an array of the positions of the data.
     */

    Model.prototype.pluck = function(property) {
      var key, prop, ref, result;
      result = [];
      ref = this._data;
      for (key in ref) {
        prop = ref[key];
        if (prop === property) {
          result.push(key);
        }
      }
      return result;
    };

    return Model;

  })(Tweak.Store);


  /*
    A View is a module used as a presentation layer. Which is used to render,
    manipulate and listen to an interface. The Model, View and Controller separates
    logic of the Views interaction to that of data and functionality. This helps to
    keep code organized and tangle free - the View should primarily be used to render,
    manipulate and listen to the presentation layer. A View consists of a template to
    which data is bound to and rendered/re-rendered.
  
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.View = (function(superClass) {
    extend(View, superClass);

    function View() {
      return View.__super__.constructor.apply(this, arguments);
    }

    $ = Tweak.$;


    /*
      Default initialiser function - called when the View has rendered
     */

    View.prototype.init = function() {};


    /*
      Default template method. This is used to generate a html fro a template engine ect, to be used during the rendering
      process. By default this method will generate a template through handlebars, it will also seek out the template
      through the module loader. This may be cross compatible with other template engines, however you can overwrite this
      method if you want to use an alternative non-compatible template engine. There may also be an extension available
      for your chosen template engine. Search [name]Tweaked for possible premade extensions.
      @param [Object] data An object of data that can be passed to the template.
      @return [String] Returns a string representaion of HTML to attach to view during render.
     */

    View.prototype.template = function(data) {
      var config, ref;
      return (((ref = (config = this.component.config.view)) != null ? ref.template : void 0) ? Tweak.request(config.template) : Tweak.findModule(this.component.paths, './template'))(data);
    };


    /*
      Default attach method. This is used to attach a HTML string to an element. You can override this method with your
      own attachment functionality.
    
      @param [DOMElement] element A DOMElement or a string representing a selector query if using a selector engine.
      @param [String] content A HTML representation of a string
      @return [DOMElement] Returns athe attached DOMElement
     */

    View.prototype.attach = function(parent, content) {
      var e, item, j, len, method, num, ref, ref1, ref2;
      content = $(content)[0];
      switch (method = (ref = this.component.config.view) != null ? (ref1 = ref.attach) != null ? ref1.method : void 0 : void 0) {
        case 'prefix':
        case 'before':
          parent.insertBefore(content, parent.firstChild);
          return parent.firstElementChild;
        case 'replace':
          ref2 = parent.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            item = ref2[j];
            try {
              parent.removeChild(item);
            } catch (_error) {
              e = _error;
            }
          }
          parent.appendChild(content);
          return parent.firstElementChild;
        default:
          if (/^\d+$/.test("" + method)) {
            num = Number(method);
            parent.insertBefore(content, parent.children[num]);
            return parent.children[num];
          } else {
            parent.appendChild(content);
            return parent.lastElementChild;
          }
      }
    };


    /*
      Checks to see if the item is attached to ; this is determined if the node has a parentNode.
      @return [Boolean] Returns whether the View has been rendered.
     */

    View.prototype.isAttached = function(element, parent) {
      if (element == null) {
        element = this.el;
      }
      if (parent == null) {
        parent = document.documentElement;
      }
      return parent.contains(element);
    };


    /*
      Renders the View, using a html template engine. The View is loaded asynchronously, this prevents the DOM from
      from congesting during rendering. The View won't be rendered until its parent View is rendered and any other
      components Views that are waiting to be rendered; this makes sure that components are rendered into in there
      correct positions.
      
      @param [Boolean] silent (Optional, default = false) If true events are not triggered upon any changes.
      @event rendered The event is called when the View has been rendered.
     */

    View.prototype.render = function(silent) {
      var _getAttachment, attachment, classNames, config, name, names, parent, ref, ref1;
      if (this.isAttached() && !silent) {
        return this.triggerEvent('rendered');
      }
      config = this.component.config.view;
      _getAttachment = (function(_this) {
        return function(parent) {
          var check, child, name, ref;
          child = null;
          if (!parent) {
            return;
          }
          check = function(elements) {
            var attachment, j, len, prop, results1, val;
            results1 = [];
            for (j = 0, len = elements.length; j < len; j++) {
              prop = elements[j];
              if (child) {
                break;
              }
              attachment = prop.getAttribute('data-attach');
              if ((attachment != null) && !attachment.match(/^\s+$/)) {
                results1.push((function() {
                  var k, len1, ref, results2;
                  ref = Tweak.splitPaths(attachment);
                  results2 = [];
                  for (k = 0, len1 = ref.length; k < len1; k++) {
                    val = ref[k];
                    val = Tweak.toAbsolute(this.component.parent.name || '', val);
                    if (name === val) {
                      child = prop;
                      break;
                    } else {
                      results2.push(void 0);
                    }
                  }
                  return results2;
                }).call(_this));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          };
          name = ((ref = config.attach) != null ? ref.to : void 0) || _this.component.name;
          check(parent);
          check($('[data-attach]', parent));
          return child;
        };
      })(this);
      parent = (ref = this.component.parent) != null ? (ref1 = ref.view) != null ? ref1.el : void 0 : void 0;
      attachment = _getAttachment(parent) || _getAttachment(document.documentElement) || parent || document.documentElement;
      this.$el = $(this.attach(attachment, this.template(this.component.config.view.data || this.model._data)));
      this.el = this.$el[0];
      names = Tweak.clone(this.component.paths);
      if (names.indexOf(this.component.name) === -1) {
        names.unshift(this.component.name);
      }
      classNames = (function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = names.length; j < len; j++) {
          name = names[j];
          results1.push(name.replace(/[\/\\]/g, '-'));
        }
        return results1;
      })();
      this.$el.addClass(classNames.join(' '));
      if (!silent) {
        this.triggerEvent('rendered');
      }
      this.init();
    };


    /*
      Clears and element and removes event listeners on itself and child DOM elements.
      @param [String, DOMElement] element A DOMElement or a string representing a selector query if using a selector engine.
     */

    View.prototype.clear = function(element) {
      if (element == null) {
        element = this.el;
      }
      $(element).remove();
    };


    /*
      Select a DOMElement from within the assigned view element
      @param [String, DOMElement] element A DOMElement or a string representing a selector query if using a selector engine.
      @param [DOMElement] root (Default = @el) The element root to search for elements with a selector engine.
      @return [Array<DOMElement>] An array of DOMElements.
     */

    View.prototype.element = function(element, root) {
      var item, j, len, results1;
      if (root == null) {
        root = this.el;
      }
      if (element instanceof Array) {
        results1 = [];
        for (j = 0, len = element.length; j < len; j++) {
          item = element[j];
          results1.push($(item, root));
        }
        return results1;
      } else {
        return $(element, root);
      }
    };

    return View;

  })(Tweak.Events);


  /*
    A Controller defines the business logic between other modules. It can be used to control data flow, logic and more. It
    should process the data from the Model, interactions and responses from the View, and control the logic between other
    modules.
  
    The Controller is the 'Middle man'; eliminating logic from the views. This prevents complexity and further organizes
    your code. It is not a required module to use, however every component has one for you to use. The benefits of the
    controller can include preprocessing of information and set-up of Components with its modules prior and after
    rendering a View. A Component upon its initialization will call the init method of its Controller module.
  
    Examples are not exact, and will not directly represent valid code; the aim of an example is to be a rough guide. JS
    is chosen as the default language to represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language. Support can be found through the
    community if needed. Please see our Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Controller = (function(superClass) {
    extend(Controller, superClass);

    function Controller() {
      return Controller.__super__.constructor.apply(this, arguments);
    }


    /*
      By default, this does nothing during initialization unless it is overridden.
    
      Note: You can apply logic to the constructor of the Controller, but you will not have any access to the other
      modules of the Component until the Component has been initialized.
    
      @example Providing set-up to a Component through the Controller.
      
        // Register the Controller to the Component's path name with a Module loader, this will allow the Component to
        // find its relating modules.
        // Using a CommonJS set-up
        
        require.register('dummy/controller', function(exports, require, module) {
          var DummyComponentController;
          return module.exports = exports = DummyComponentController = (function() {
            function DummyComponentController() {}
    
            Tweak.extends(DummyComponentController, Tweak.Controller);
    
            DummyComponentController.prototype.init = function() {          
              // By passing true to to @model.set the model quietly updates            
              return this.model.set('topping', this.component.config.topping, true);
            };
    
            return DummyComponentController;
    
          })();
        });
     */

    Controller.prototype.init = function() {};

    return Controller;

  })(Tweak.Events);


  /*
    A Collection is used by other modules like the Controller to store, retrieve and
    listen to a set of ordered data. A Collection triggers events when its storage
    base is updated, this makes it easy to listen to changes and to action as and
    when required. The Collection data is not a database, but a JSON representation
    of its data can be exported and imported to and from storage sources. In Tweak.js
    the Model extends the Store module - which is the core functionality shared between
    Model's and Collection's. The main difference between a Model and collection it
    the base of its data type. The Model uses an object as its base data type and a
    collection base type is an Array.
  
    To further extend a Collection, Tweak.js allows data to be imported and exported.
    When doing this please know that all data stored should be able to be converted
    to a JSON string. A Collection of Models can also be exported and imported to
    and from a database, as it has an inbuilt detection for when a value should be
    created as a Model representation. Keep note that a Collection of Collections is
    not appropriate as this becomes complicated and it can get messy quickly. It
    should be possible to export and import data of that nature, but itâ€™s not
    recommended - always try to keep stored data structured simply.
  
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Collection = (function(superClass) {
    var __fullTrigger;

    extend(Collection, superClass);

    function Collection() {
      return Collection.__super__.constructor.apply(this, arguments);
    }

    Collection.prototype.__base = function() {
      return [];
    };


    /*
      @private
      Method to trigger a change event for all of the properties in the Collection
     */

    __fullTrigger = function(data, trigger) {
      var item, key;
      for (key in data) {
        item = data[key];
        trigger("changed:" + key, item);
      }
      return triggerEvent('changed', data);
    };


    /*
      Add a new property to the end of the Collection.
      @param [*] data Data to add to the end of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.add = function(data, silent) {
      this.set(this.length, data, silent);
    };


    /*
      Get an element at specified index.
      @param [Number] index Index of property to return.
      @return [*] Returned data from the specified index.
     */

    Collection.prototype.at = function(index) {
      return this.get(index);
    };


    /*
      Push a new property to the end of the Collection.
      @param [*] data Data to add to the end of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.push = function(data, silent) {
      this.set(this.length, data, silent);
    };


    /*
      Splice method that allows for event triggering on the base object.
      @param [Number] position The position to insert the property at into the Collection.
      @param [Number] remove The amount of properties to remove from the Collection.
      @param [Array<*>] data an array of data to insert into the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
      @example Removing four properties from the 6th position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(5, 4);
    
      @example Inserting two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(2, 0, ['100', '200']);
    
      @example Silently insert two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(2, 0, ['100', '200'], true);
     */

    Collection.prototype.splice = function(position, remove, data, silent) {
      var ref;
      if (silent == null) {
        silent = false;
      }
      (ref = this._data).splice.apply(ref, [position, remove].concat(slice.call(data)));
      this.length = this._data.length;
      if (!silent) {
        __fullTrigger(this._data, this.triggerEvent);
      }
    };


    /*
      Insert values into base data at a given index (Short cut to splice method).
      @param [Number] index The index to insert the property at into the Collection.
      @param [Array<*>] data an array of data to insert into the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{key} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
    
    
      @example Inserting two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.insert(2, ['100', '200']);
    
      @example Silently insert two properties from the 3rd position in the array.
        var collection;
        collection = new tweak.Collection();
        collection.splice(2, ['100', '200'], true);
     */

    Collection.prototype.insert = function(index, data, silent) {
      this.splice(position, 0, data, silent);
    };


    /*
      Adds property to the first index of the Collection.
      @param [Array<*>] data an array of data to insert at the first index of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
      @return [Number] The length of the Collection.
     */

    Collection.prototype.unshift = function(data, silent) {
      this.splice(0, 0, data, silent);
      return this.length;
    };


    /*
      Remove a single property or many properties from the Collection.
    
      @overload remove(index, silent)
        Remove an individual property from the Collection.
        @param [String] index The index to remove from the Collection.
        @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes to the data.
    
      @overload remove(data, silent)
        Remove multiple properties from the Collection by an Array of keys (Strings).
        @param [Array] keys An array of keys (indexes) to remove.
        @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes to the data.
    
      @event removed:#{index} Triggers an event based on what properties have been removed.
      @event changed Triggers a generic event that the Collection has been changed.
    
      @example Remove a single property.
        var collection;
        collection = new tweak.Collection();
        collection.remove(3);
    
      @example Remove multiple properties.
        var collection;
        collection = new tweak.Collection();
        collection.remove([1,3]);
    
      @example Remove properties silently.
        var collection;
        collection = new tweak.Collection();
        collection.remove([4,2], true);
        collection.remove(1, true);
     */

    Collection.prototype.remove = function(keys, silent) {
      var index, j, len;
      if (!(keys instanceof Array)) {
        keys = [keys];
      }
      for (j = 0, len = keys.length; j < len; j++) {
        index = keys[j];
        this._data.splice(index, 1);
        if (!silent) {
          this.triggerEvent("removed:" + index);
        }
      }
      if (!silent) {
        this.triggerEvent('changed');
      }
    };


    /*
      Remove an element at a specified index.
      @param [Number] index Index of property to remove.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
      
      @example Remove a property at a given index.
        var collection;
        collection = new tweak.Collection();
        collection.removeAt(1);
    
      @example Silently remove a property at a given index.
        var collection;
        collection = new tweak.Collection();
        collection.removeAt(3, true);
     */

    Collection.prototype.removeAt = function(index, silent) {
      var element, key, prop;
      element = this.at(index);
      for (key in element) {
        prop = element[key];
        this.remove(key, silent);
      }
    };


    /*
      Remove a property at the last index of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event removed:#{key} Triggers an event based on what property has been removed.
      @event changed Triggers a generic event that the Collection has been updated.
      @return [*] The property value that was removed.
    
      @example Remove the last property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.pop();
    
      @example Silently remove the last property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.pop(true);
     */

    Collection.prototype.pop = function(silent) {
      var length, result;
      length = this.length - 1;
      result = this._data[length];
      this.remove(length, silent);
      return result;
    };


    /*
      Remove a property at the first index of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event removed:#{key} Triggers an event based on what property has been removed.
      @event changed Triggers a generic event that the Collection has been updated.
      @return [*] The property value that was removed.
    
      @example Remove the first property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.shift();
    
      @example Silently remove the first property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.shift(true);
     */

    Collection.prototype.shift = function(silent) {
      var result;
      result = this._data[0];
      this.remove(0, silent);
      return result;
    };


    /*
      Reduce the collection by removing properties from the first index.
      @param [Number] length The length of the Array to shorten to.
    
      @example Remove the first five properties from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5);
    
      @example Silently remove the first five property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5, true);
     */

    Collection.prototype.reduce = function(length, silent) {
      this.splice(0, length, silent);
    };


    /*
      Reduce the collection by removing properties from the last index.
      @param [Number] length The length of the Array to shorten to.
    
      @example Remove the first five properties from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5);
    
      @example Silently remove the first five property from the Collection.
        var collection;
        collection = new tweak.Collection();
        collection.reduce(5, true);
     */

    Collection.prototype.reduceRight = function(length, silent) {
      this.splice(0, this.length - length, silent);
    };


    /*
      Returns an Array of keys (indexes) where the Collection properties match the specified value.
      @param [*] value The value to find a match against.
      @return [Array] An Array of indexes where the Collection properties match the specified value.
    
      @example Retrieve the keys (indexes) where the value 'dog' can be found.
        var collection;
        collection = new tweak.Collection();
        collection.indexes('dog');
     */

    Collection.prototype.indexes = function(value) {
      var index, prop, ref, results1;
      ref = this._data;
      results1 = [];
      for (index in ref) {
        prop = ref[index];
        if (value === prop) {
          results1.push(index);
        }
      }
      return results1;
    };


    /*
      Concatenate Arrays to the end of the Collection.
      @param [Array] arrays An Array containing a set of Arrays to concatenate to the end of the Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes to the data.
    
      @note As it may be that the Collection is to be updated silently when using this method. The Arrays to concatenate to the end of the Collection has to be wrapped in an Array.
      @example Concatenate a set of Arrays to the end of a collection.
        var collection;
        collection = new tweak.Collection();
        collection.concat([[1,4,6], ['dog', 'cat']);
    
      @example Silently concatenate a set of Arrays to the end of a collection.
        var collection;
        collection = new tweak.Collection();
        collection.concat([['frog', 'toad']], true);
     */

    Collection.prototype.concat = function(arrays, silent) {
      var ref;
      this.splice(this.length - 1, 0, (ref = []).concat.apply(ref, arrays), silent);
    };


    /*
      This method directly accesses the Collection's data's every method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
     */

    Collection.prototype.every = function() {
      return this._data.every(arguments);
    };


    /*
      This method directly accesses the Collection's data's filter method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
     */

    Collection.prototype.filter = function() {
      return this._data.filter(arguments);
    };


    /*
      This method directly accesses the Collection's data's forEach method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
     */

    Collection.prototype.forEach = function() {
      return this._data.forEach(arguments);
    };


    /*
      This method directly accesses the Collection's data's join method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join
     */

    Collection.prototype.join = function() {
      return this._data.join(arguments);
    };


    /*
      This method directly accesses the Collection's data's map method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
     */

    Collection.prototype.map = function() {
      return this._data.map(arguments);
    };


    /*
      This method directly accesses the Collection's data's reverse method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse
    
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.reverse = function(silent) {
      var result;
      result = this._data.reverse();
      if (!silent) {
        __fullTrigger(this._data, this.triggerEvent);
      }
      return result;
    };


    /*
      This method directly accesses the Collection's data's slice method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
     */

    Collection.prototype.slice = function() {
      return this._data.slice(arguments);
    };


    /*
      This method directly accesses the Collection's data's some method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
     */

    Collection.prototype.some = function() {
      return this._data.some(arguments);
    };


    /*
      This method directly accesses the Collection's data's sort method.
      See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    
      @param [Function] fn (optional) If a comparing function is present then this is passed to sort function.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
    
      @event changed:#{index} Triggers an event and passes in changed property.
      @event changed Triggers a generic event that the Collection has been updated.
     */

    Collection.prototype.sort = function(fn, silent) {
      var result;
      if (silent == null) {
        silent = false;
      }
      result = fn != null ? this._data.sort(fn) : this._data.sort();
      __fullTrigger(this._data, this.triggerEvent);
      return result;
    };

    return Collection;

  })(Tweak.Store);


  /*
    The future of MVC doesn't always lie in web applications; the architecture to
    TweakJS allows for integration of components anywhere on a website. For example
    you can plug "Web Components" into your static site; like sliders, accordions.
    The flexibility is endless; allowing MVC to be used from small web components
    to full scale one page web applications.
  
    TweakJS wraps its Models, Views, Templates, and Controllers into a Component
    module. The Component module acts intelligently to build up your application
    with simple configuration files. Each Component its built through a config
    object; this allows for powerful configuration with tonnes of flexibility.
    The config objects are extremely handy for making Components reusable, with
    easy accessible configuration settings.
  
    Each Component can have sub Components which are accessible in both directions;
    although it is recommended to keep functionality separate it sometimes comes in
    handy to have access to other parts of the application. Each Component can
    extend another Component, which will then inherent the models, views, templates,
    and controllers directly from that Component. If you however want to extend a
    Component using a different Model you can simply overwrite that model, or extend
    the functionality to the inherited model Components model.
  
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Component = (function() {
    Component.prototype.model = null;

    Component.prototype.view = null;

    Component.prototype.components = null;

    Component.prototype.controller = null;

    Component.prototype.router = null;

    Component.prototype.modules = ['controller', 'model', 'view', 'router', 'components'];


    /*
      @param [Object] relation Relation to the Component.
      @param [Object] options Configuration for the Component.
     */

    function Component(relation, options) {
      var j, k, len, len1, name, name2, prop, prop2, ref, ref1;
      if (options == null) {
        throw new Error('No options given');
      }
      relation = this.relation = relation === window ? {} : relation;
      if (relation.relation == null) {
        relation.relation = {};
      }
      this.parent = relation instanceof Tweak.Component ? relation : relation.component || relation;
      this.root = this.parent.root || this;
      this.name = options.name;
      if (this.name == null) {
        throw new Error('No name given');
      }
      options.name = this.name = Tweak.toAbsolute(this.parent.name || '', this.name);
      this.config = this.__buildConfig(options);
      if (this.config.router) {
        this.__addRouter();
      }
      this.__addModel();
      this.__addView();
      this.__addComponents();
      this.__addController();
      ref = this.modules;
      for (j = 0, len = ref.length; j < len; j++) {
        name = ref[j];
        if (!(prop = this[name])) {
          continue;
        }
        prop.parent = this.parent;
        prop.component = this;
        ref1 = this.modules;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          name2 = ref1[k];
          if (name !== name2 && (prop2 = this[name2])) {
            prop[name2] = prop2;
          }
        }
      }
    }


    /*
      When the component is initialised it's modules are also initialised.
     */

    Component.prototype.init = function() {
      var item, j, len, name, ref;
      ref = this.modules;
      for (j = 0, len = ref.length; j < len; j++) {
        name = ref[j];
        if (name !== 'view' && (item = this[name])) {
          if (typeof item.init === "function") {
            item.init();
          }
        }
      }
    };


    /*
      @private
      Builds the configuration object for the Component.
      @param [Object] options Component options.
      @return [Object] Combined config based on the components inheritance.
     */

    Component.prototype.__buildConfig = function(options) {
      var configs, extension, i, j, name, paths, ref, ref1, requested, result;
      configs = [];
      paths = this.paths = [];
      extension = this.name;
      if (options) {
        configs.push(Tweak.clone(options));
        if (options["extends"]) {
          extension = options["extends"];
        }
      }
      name = ((ref = this.parent) != null ? ref.name : void 0) || this.name;
      while (extension) {
        requested = Tweak.request(name, extension + "/config", Tweak.strict ? null : {});
        paths.push(Tweak.toAbsolute(name, extension));
        configs.push(Tweak.clone(requested));
        extension = requested["extends"];
      }
      result = configs[configs.length - 1];
      for (i = j = ref1 = configs.length - 1; ref1 <= 0 ? j <= 0 : j >= 0; i = ref1 <= 0 ? ++j : --j) {
        result = Tweak.combine(result, configs[i]);
      }
      if (result.model == null) {
        result.model = {};
      }
      if (result.view == null) {
        result.view = {};
      }
      if (result.controller == null) {
        result.controller = {};
      }
      if (result.components == null) {
        result.components = [];
      }
      if (result.events == null) {
        result.events = {};
      }
      return result;
    };


    /*
      @private
      Add a module to the Component, if module can't be found then it will use a surrogate object.
      @param [String] name Name of the module.
      @param [Object] surrogate Surrogate if the module can not be found.
      @param [...] params Parameters passed into the module on construction.
     */

    Component.prototype.__addModule = function() {
      var Module, module, name, params, surrogate;
      name = arguments[0], surrogate = arguments[1], params = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      Module = Tweak.findModule(this.paths, "./" + name, surrogate);
      module = this[name] = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Module, [this.config[name]].concat(slice.call(params)), function(){});
      module.component = this;
      module.root = this.root;
    };


    /*
      @private
      Short cut method to adding view using the addModule method.
      @param [...] params Parameters passed to into the view constructor.
     */

    Component.prototype.__addView = function() {
      var params;
      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.__addModule.apply(this, ['view', Tweak.View].concat(slice.call(params)));
    };


    /*
      @private
      Short cut method to adding Model using the addModule method.
      @param [...] params Parameters passed to into the model constructor.
     */

    Component.prototype.__addModel = function() {
      var params;
      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.__addModule.apply(this, ['model', Tweak.Model].concat(slice.call(params)));
    };


    /*
      @private
      Short cut method to adding controller using the addModule method.
      @param [...] params Parameters passed to into the controller constructor.
     */

    Component.prototype.__addController = function() {
      var params;
      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.__addModule.apply(this, ['controller', Tweak.Controller].concat(slice.call(params)));
    };


    /*
      @private
      Add module to this Component.
      @param [...] params Parameters passed to into the Components constructor.
     */

    Component.prototype.__addComponents = function() {
      var params;
      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.__addModule.apply(this, ['components', Tweak.Components].concat(slice.call(params)));
    };


    /*
      @private
      Short cut method to adding router using the addModule method.
      @param [...] params Parameters passed to into the router constructor.
     */

    Component.prototype.__addRouter = function() {
      var params;
      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      this.__addModule.apply(this, ['router', Tweak.Router].concat(slice.call(params)));
    };


    /*
      @private
      Reusable method to render and re-render.
      @param [String] type The type of rendering to do either 'render' or 'rerender'.
     */

    Component.prototype.__componentRender = function(type) {
      this.view.addEvent(type + "ed", function() {
        this.components.addEvent('ready', function() {
          return this.controller.triggerEvent('ready');
        }, this, 1);
        return this.components[type]();
      }, this, 1);
      this.view[type]();
    };


    /*
      Renders itself and its subcomponents.
      @event ready Triggers ready event when itself and its Components are ready/rendered.
     */

    Component.prototype.render = function() {
      var name;
      name = this.name;
      this.__componentRender('render');
    };


    /*
      Re-renders itself and its subcomponents.
      @event ready Triggers ready event when itself and its Components are ready/re-rendered.
     */

    Component.prototype.rerender = function() {
      this.__componentRender('rerender');
    };


    /*
      Destroy this Component. It will clear the view if it exists; and removes it from the Components Collection.
      @param [Boolean] silent (optional, default = false) If true events are not triggered upon any changes.
     */

    Component.prototype.destroy = function(silent) {
      var components, i, item, j, len, ref;
      this.view.clear();
      components = this.relation.components;
      if (components != null) {
        i = 0;
        ref = components.data;
        for (j = 0, len = ref.length; j < len; j++) {
          item = ref[j];
          if (item.uid === this.uid) {
            components.remove(i, silent);
            return;
          }
          i++;
        }
      }
    };


    /*
      Short-cut to the controllers findEvent method.
    
      @overload findEvent(names, build)
        Find events on controller with a space separated string.
        @param [String] names The event name(s); split on a space.
        @param [Boolean] build (Default = false) Whether or not to add an event object to the controller when none can be found.
        @return [Array<Event>] All event objects that are found/created then it is returned in an Array.
    
      @overload findEvent(names, build)
        Find events on controller with an array of names (strings).
        @param [Array<String>] names An array of names (strings).
        @param [Boolean] build (Default = false) Whether or not to add an event object to the controller when none can be found.
        @return [Array<Event>] All the controllers event objects that are found/created then it is returned in an Array.
     */

    Component.prototype.findEvent = function(names, build) {
      return this.controller.findEvent(names, build);
    };


    /*
      Short-cut to the controllers addEvent method.
    
      @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
      @param [Function] callback The event callback function.
      @param [Number] maximum (Default = null). The maximum calls on the event listener. After the total calls the events callback will not invoke.
      @param [Object] context The contextual object of which the event to be bound to.
     */

    Component.prototype.addEvent = function(names, callback, max, context) {
      return this.controller.addEvent(names, callback, max, context);
    };


    /*
      Short cut to the controllers removeEvent method.
    
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Function] callback (optional) The callback function of the event. If no specific callbacki s given then all the controller events under event name are removed.
      @param [Object] context (default = this) The contextual object of which the event is bound to. If this matches then it will be removed, however if set to null then all events no matter of context will be removed.
     */

    Component.prototype.removeEvent = function(names, callback, context) {
      return this.controller.removeEvent(names, callback, context);
    };


    /*
      Short cut to the controllers triggerEvent method.
    
      @overload triggerEvent(names, params)
        Trigger events on controller by name only.
        @param [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @param [...] params Parameters to pass into the callback function.
    
      @overload triggerEvent(options, params)
        Trigger events on controller by name and context.
        @param [Object] options Options and limiters to check against callbacks.
        @param [...] params Parameters to pass into the callback function.
        @option options [String, Array<String>] names The event name(s). Split on a space, or an array of event names.
        @option options [Context] context (Default = null) The context of the callback to check against a callback.
     */

    Component.prototype.triggerEvent = function() {
      var names, params, ref;
      names = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return (ref = this.controller).triggerEvent.apply(ref, [names].concat(slice.call(params)));
    };


    /*
      Shortcut to the controllers updateEvent method.
    
      @param [String] names The event name(s). Split on a space, or an array of event names.
      @param [Object] options Optional limiters and update values.
      @option options [Object] context The contextual object to limit updating events to.
      @option options [Function] callback Callback function to limit updating events to.
      @option options [Number] max Set a new maximum calls to an event.
      @option options [Number] calls Set the amount of calls that has been triggered on this event.
      @option options [Boolean] reset (Default = false) If true then calls on an event get set back to 0.
      @option options [Boolean] listen Whether to enable or disable listening to event.
     */

    Component.prototype.updateEvent = function(names, options) {
      return this.controller.updateEvent(names, options);
    };


    /*
      Resets the controllers events to empty.
     */

    Component.prototype.resetEvents = function() {
      return this.controller.resetEvents();
    };


    /*
      This method is used to extract all data of a component. If there is an export method within the Component Controller
      then the Controller export method will be executed with the data returned from the method.
      @param [Object] limit Limit the data from model to be exported
      @return [Object] Extracted data from Component.
     */

    Component.prototype["export"] = function(limit) {
      var base1;
      return (typeof (base1 = this.controller)["export"] === "function" ? base1["export"]() : void 0) || {
        model: this.model["export"](limit, {
          components: this.components["export"]()
        })
      };
    };


    /*
      This method is used to import data into a component. If there is an import method within the Component Controller
      then the Controller import method will be executed with the data passed to the method.
      @param [Object] data Data to import to the Component.
      @option data [Object] model Object to import into the Component's Model.
      @option data [Array<Object>] components Array of Objects to import into the Component's Components.
     */

    Component.prototype["import"] = function(data) {
      if (this.controller["import"] != null) {
        return this.controller["import"](data);
      } else {
        if (data.model) {
          this.model["import"](data.model);
        }
        if (data.components) {
          return this.components["import"](data.components);
        }
      }
    };

    return Component;

  })();


  /*
    This class provides a collection of components. Upon initialisation components
    are dynamically built, from its configuration. The configuration for this
    component is an Array of component names (Strings). The component names are
    then used to create a component. Components nested within those components are
    then initialised creating a powerful scope of nest components that are completely
    unique to themselves.
  
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
   */

  Tweak.Components = (function(superClass) {
    extend(Components, superClass);

    function Components() {
      return Components.__super__.constructor.apply(this, arguments);
    }


    /*
     Construct the Collection with given options from the Components configuration.
     */

    Components.prototype.init = function() {
      var _absolute, _add, _extends, _paths, data, item, j, k, l, len, len1, len2, len3, m, name, obj, ref, ref1, ref2, ref3;
      this._data = [];
      data = [];
      _absolute = (function(_this) {
        return function(path) {
          return Tweak.toAbsolute(_this.component.name, path);
        };
      })(this);
      _paths = (function(_this) {
        return function(paths) {
          var j, len, path, ref, results1;
          ref = Tweak.splitPaths(paths);
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            path = ref[j];
            results1.push(_absolute(path));
          }
          return results1;
        };
      })(this);
      _add = (function(_this) {
        return function(component) {
          _this._data.push(component);
          _this.length++;
          return component.init();
        };
      })(this);
      ref = this.component.config.components;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        obj = {};
        if (item instanceof Array) {
          _extends = _absolute(item[1]);
          ref1 = _paths(item[0]);
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            name = ref1[k];
            _add(new Tweak.Component(this, {
              path: path,
              "extends": _extends
            }));
          }
        } else if (typeof item === 'string') {
          ref2 = _paths(item);
          for (l = 0, len2 = ref2.length; l < len2; l++) {
            name = ref2[l];
            _add(new Tweak.Component(this, {
              name: name
            }));
          }
        } else {
          item["extends"] = _absolute(item["extends"]);
          ref3 = _paths(item.name);
          for (m = 0, len3 = ref3.length; m < len3; m++) {
            name = ref3[m];
            item.name = name;
            _add(new Tweak.Component(this, item));
          }
        }
      }
    };


    /*
      @private
      Reusable method to render and re-render.
      @param [String] type The type of rendering to do either 'render' or 'rerender'.
     */

    Components.prototype.__componentRender = function(type) {
      var item, j, len, ref;
      if (this.length === 0) {
        this.triggerEvent('ready');
      } else {
        this.total = 0;
        ref = this._data;
        for (j = 0, len = ref.length; j < len; j++) {
          item = ref[j];
          item.controller.addEvent('ready', function() {
            if (++this.total === this.length) {
              return this.triggerEvent('ready');
            }
          }, this, 1);
          item[type]();
        }
      }
    };


    /*
      Renders all of its Components.
      @event ready Triggers ready event when itself and its sub-Components are ready/rendered.
     */

    Components.prototype.render = function() {
      this.__componentRender('render');
    };


    /*
      Re-render all of its Components.
      @event ready Triggers ready event when itself and its sub-Components are ready/re-rendered.
     */

    Components.prototype.rerender = function() {
      this.__componentRender('rerender');
    };


    /*
      Find Component with matching data in model.
      @param [String] property The property to find matching value against.
      @param [*] value Data to compare to.
      @return [Array] An array of matching Components.
     */

    Components.prototype.whereData = function(property, value) {
      var collectionKey, componentData, data, key, modelData, prop, result;
      result = [];
      componentData = this._data;
      for (collectionKey in componentData) {
        data = componentData[collectionKey];
        modelData = data.model.data || model.data;
        for (key in modelData) {
          prop = modelData[key];
          if (key === property && prop === value) {
            result.push(data);
          }
        }
      }
      return result;
    };


    /*
      Reset this Collection of components. Also destroys it's components (views removed from DOM).
      @event changed Triggers a generic event that the store has been updated.
     */

    Components.prototype.reset = function() {
      var item, j, len, ref;
      ref = this._data;
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        item.destroy();
      }
      Components.__super__.reset.call(this);
    };

    return Components;

  })(Tweak.Collection);


  /*
    Simple cross browser history API. Upon changes to the history a change event is
    called. The ability to hook event listeners to the tweak.History API allows
    routes to be added accordingly, and for multiple Routers to be declared for
    better code structure.
  
    Examples are in JS, unless where CoffeeScript syntax may be unusual. Examples
    are not exact, and will not directly represent valid code; the aim of an example
    is to show how to roughly use a method.
   */

  Tweak.History = (function(superClass) {
    var __toggleListener;

    extend(History, superClass);

    History.prototype.usePush = true;

    History.prototype.useHash = false;

    History.prototype.started = false;

    History.prototype.root = '/';

    History.prototype.iframe = null;

    History.prototype.url = null;

    History.prototype.__interval = null;

    History.prototype.intervalRate = 50;


    /*
      Checks that the window and history is available.
      This addr support for the history to work outside of browsers
      if the window, history and location are set manually.
     */

    function History() {
      this.__checkChanged = bind(this.__checkChanged, this);
      if (typeof window !== 'undefined') {
        this.location = (this.window = window).location;
        this.history = window.history;
      }
    }


    /*
      Start listening to the URL changes to push back the history API if available.
      
      @param [Object] options An optional object to pass in optional arguments
      @option options [Boolean] useHash (default = false) Specify whether to use hashState if true then pushState will be set to false.
      @option options [Boolean] forceRefresh (default = false) When set to true then pushState and hashState will not be used.
      @option options [Number] interval (default = null) When set to a number this is what the refresh rate will be when an interval has to be used to check changes to the URL.
      @option options [Boolean] silent (default = false) If set to true then an initial change event trigger will not be called.
      
      @event changed When the URL is updated a change event is fired from tweak.History.
    
      @example Starting the history with auto configuration.
        tweak.History.start();
    
      @example Starting the history with forced HashState.
        tweak.History.start({
          hashState:true
        });
    
      @example Starting the history with forced PushState.
        tweak.History.start({
          pushState:true
        });
    
      @example Starting the history with forced refresh or page.
        tweak.History.start({
          forceRefresh:true
        });
    
      @example Starting the history with an interval rate for the polling speed for older browsers.
        tweak.History.start({
          hashState:true,
          interval: 100
        });
    
      @example Starting the history silently.
        tweak.History.start({
          hashState:true,
          silent: true
        });
     */

    History.prototype.start = function(options) {
      var body, frame, location, ref, url, useHash, usePush;
      if (options == null) {
        options = {};
      }
      if (this.started) {
        return;
      }
      this.started = true;
      usePush = this.usePush = options.useHash ? false : (ref = this.history) != null ? ref.pushState : void 0;
      useHash = this.useHash = !usePush;
      if (options.forceRefresh || (useHash && !('onhashchange' in this.window))) {
        this.usePush = this.useHash = useHash = usePush = false;
      }
      if (options.interval) {
        this.intervalRate = options.interval;
      }
      this.root = root = ("/" + (options.root || '/') + "/").replace(/^\/+|\/+$/g, '/');
      this.url = url = this.__getURL();
      location = this.location;
      if (useHash) {
        this.location.replace(root + "#" + (this.__getPath()) + (this.__getHash()));
      } else if (usePush && this.__getHash() !== '') {
        this.set(this.__getHash(), {
          replace: true
        });
      }
      if (!usePush && !useHash && !options.forceRefresh) {
        frame = document.createElement('iframe');
        frame.src = 'javascript:0';
        frame.style.display = 'none';
        frame.tabIndex = -1;
        body = document.body;
        this.iframe = body.insertBefore(frame, body.firstChild).contentWindow;
        this.__setHash(this.iframe, "#" + url, false);
      }
      this.__toggleListeners();
      if (!options.silent) {
        return this.triggerEvent('changed', this.url.replace(/^\/+/, ''));
      }
    };


    /*
     Stop tweak.History. Most likely useful for a web component that uses the history to change state,
     but if removed from page then component may want to stop the history.
     */

    History.prototype.stop = function() {
      this.__toggleListeners('remvoe');
      return this.started = false;
    };


    /*
      Set the URL and add the URL to history.
      
      @param [Object] options An optional object to pass in optional arguments.
      @option options [Boolean] replace (default = false) Specify whether to replace the current item in the history.
      @option options [Boolean] silent (default = true) Specify whether to allow triggering of event when setting the URL.
    
      @example Setting the History (updating the URL).
        tweak.History.set('/#/fake/url');
    
      @example Replacing the last History state (updating the URL).
        tweak.History.set('/#/fake/url', {
          replace:true
        });
    
      @example Setting the History (updating the URL) and calling history change event.
        tweak.History.set('/#/fake/url', {
          silent:false
        });
     */

    History.prototype.set = function(url, options) {
      var fullUrl, replace;
      if (options == null) {
        options = {};
      }
      if (!this.started) {
        return;
      }
      if (options.silent == null) {
        options.silent = true;
      }
      replace = options.replace;
      url = this.__getURL(url) || '';
      root = this.root;
      if (url === '' || url.charAt(0) === '?') {
        root = root.slice(0, -1) || '/';
      }
      fullUrl = "" + root + (url.replace(/^\/*/, ''));
      url = decodeURI(url.replace(/#.*$/, ''));
      if (this.url === url) {
        return;
      }
      this.url = url;
      if (this.usePush) {
        this.history[replace ? 'replaceState' : 'pushState']({}, document.title, fullUrl);
      } else if (this.useHash) {
        this.__setHash(this.window, url, replace);
        if (this.iframe && url !== this.__getHash(this.iframe)) {
          this.__setHash(this.iframe, url, replace);
        }
      } else {
        this.location.assign(fullURL);
        return;
      }
      if (!options.silent) {
        this.triggerEvent('changed', (this.url = url).replace(/^\/+/, ''));
      }
    };

    __toggleListener = function(prefix, type, fn) {
      var attach;
      if (window.addEventListener) {
        return element[prefix + 'EventListener'](type, fn);
      } else if (window.attachEvent) {
        attach = prefix === 'on' ? 'attach' : 'detach';
        return element[attach + 'Event']("prefix" + type, fn);
      } else {
        return element[prefix + type] = fn;
      }
    };


    /*
      @private
      Add listeners of remove history change listeners.
      @param [String] prefix (Default = 'add') Set the prefix - 'add' or 'remove'.
     */

    History.prototype.__toggleListeners = function(prefix) {
      if (prefix == null) {
        prefix = 'add';
      }
      if (this.pushState) {
        __toggleListener('popstate', this.__checkChanged);
      } else if (this.useHash && !this.iframe) {
        __toggleListener('hashchange', this.__checkChanged);
      } else if (this.useHash) {
        if (prefix === 'add') {
          this.__interval = setInterval(this.__checkChanged, this.intervalRate);
        } else {
          clearInterval(this.__interval);
          document.body.removeChild(this.iframe.frameElement);
          this.iframe = this.__interval = null;
        }
      }
    };


    /*
      @private
      Get the URL formatted without the hash.
      @param [Window] window The window to retrieve hash.
      @return Normalized URL without hash.
     */

    History.prototype.__getHash = function(window) {
      var match;
      match = (window || this).location.href.match(/#(.*)$/);
      if (match) {
        return match[1];
      } else {
        return '';
      }
    };


    /*
      @private
      Get search part of url
      @return search if it matches or return empty string.
     */

    History.prototype.__getSearch = function() {
      var match;
      match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      if (match) {
        return match[0];
      } else {
        return '';
      }
    };


    /*
      @private
      Get the pathname and search parameters, without the root.
      @return Normalized URL.
     */

    History.prototype.__getPath = function() {
      var path;
      path = decodeURI("" + this.location.pathname + (this.__getSearch()));
      root = this.root.slice(0, -1);
      if (!path.indexOf(root)) {
        path = path.slice(root.length);
      }
      if (path.charAt(0) === '/') {
        return path.slice(1);
      } else {
        return path;
      }
    };


    /*
      @private
      Get a normalized URL.
      @param [String] URL The URL to normalize - if null then URL will be retrieved from window.location.
      @param [Boolean] force Force the returning value to be hash state.
      @return Normalized URL without trailing slashes at either side.
     */

    History.prototype.__getURL = function(url, force) {
      if (url == null) {
        if (this.usePush || force) {
          url = decodeURI("" + this.location.pathname + this.location.search);
          root = this.root.replace(/\/$/, '');
          if (!url.indexOf(root)) {
            url = url.slice(root.length);
          }
        } else {
          url = this.__getHash();
        }
      }
      url = url.replace(/^\/{2,}/g, '/');
      if (!url.match(/^\/+/)) {
        url = "/" + url;
      }
      return url.replace(/\/+$/g, '');
    };


    /*
      @private
      Change the hash or replace the hash.
      @param [Location] location The location to amend the hash to. ieFrame.location or the window.location.
      @param [String] URL The URL to replace the current hash with.
      @param [Boolean] replace Whether to replace the hash by href or to change hash directly.
     */

    History.prototype.__setHash = function(window, url, replace) {
      if (this.iframe === window) {
        window.document.open().close();
      }
      if (replace) {
        window.location.replace((location.href.replace(/(javascript:|#).*$/, '')) + "#" + url);
      } else {
        window.location.hash = "" + url;
      }
    };


    /*
      @private
      Check whether the URL has been changed, if it has then trigger change event.
     */

    History.prototype.__checkChanged = function() {
      var now, old;
      now = this.__getURL();
      old = this.url;
      if (now === old) {
        if (this.iframe) {
          now = this.__getHash(this.iframe);
          this.set(now);
        } else {
          return false;
        }
      }
      this.triggerEvent('changed', this.url = now);
      return true;
    };

    return History;

  })(Tweak.Events);

  Tweak.History = new Tweak.History();


  /*
    Web applications often provide linkable, bookmark, shareable URLs for important
    locations in the application. The Router module provides methods for routing to
    events which can control the application. Traditionally it used to be that
    routers worked from hash fragments (#page/22). However, the HTML5 History API now
    provides standard URL formats (/page/22). Routers provide functionality that
    links applications/components/modules together through data passed through the URL.
  
    The router's routes can be formatted as a string that provides additional easy
    management to routing of events. A route can contain the following structure.
    Which implements splats, parameters and optional parameters.
  
    Examples are not exact, and will not directly represent valid code; the aim of
    an example is to be a rough guide. JS is chosen as the default language to
    represent Tweak.js as those using 'compile-to-languages' should have a good
    understanding of JS and be able to translate the examples to a chosen language.
    Support can be found through the community if needed. Please see our
    Gitter community for more help {http://gitter.im/blake-newman/TweakJS}.
    
    @example Route with parameters
      Adding a route ':section:page' or ':section/:page' attached to the event of 'navigation', will trigger a
      'navigation' event and pass the following data with a similar HashState of '/#/5/93'.
      {
        url:'/5/93',
        data:{
          section:'5',
          page:'93'
        }
      }
    
    @example Route with parameters one being optional
      Adding a optional parameter route ':section?page' or ':section/?page' attached to the event of 'navigation',
      will trigger a 'navigation' event and pass the following data with a similar HashState of '/#/5/6'.
      {
        url:'/5/6',
        data:{
          section:'5',
          page:'6'
        }
      }
  
      Adding a optional parameter route ':section?page' or ':section/?page' attached to the event of 'navigation',
      will trigger a 'navigation' event and pass the following data with a similar HashState of '/#/5'.
      {
        url:'/5',
        data:{
          section:'5'
        }
      }
    
    @example Route with splat
      Adding a splat route ':section:page/*' or ':section/:page/*' attached to the event of 'navigation', will
      trigger a 'navigation' event and pass the following data with a similar HashState of '/#/5/6/www.example.com'.
      {
        url:'/5/6/www.example.com',
        data:{
          section:'5',
          page:'6',
          splat:'www.example.com'
        }
      }
    
    @example URL with query string
      When you want to use URLs that contain a query string, '/blog?id=9836384&light&reply=false', then the data
      sent back to an event will look like:
      {
        url:'/blog?id=9836384&light&reply=false',
        data:{
          blog:{
            id:9836384,
            light:'true',
            reply:'false'
          }
        }
      }
   */

  Tweak.Router = (function(superClass) {
    var __getKeys, __getQueryData, __paramReg, __toRegex;

    extend(Router, superClass);


    /*
      The constructor initialises the routers unique ID, routes, and event listening.
      
      @param [object] routes (optional, default = {}) An object containing event name based keys to an array of routes.
    
      @example Creating a Router with a set of predefined routes.
        var router;
        router = new tweak.Router({
          'navigation':[
            ':section/:page',
            /:website/:section/?page
          ],
          'demo':[
            ':splat/:example/*'
          ]
        });
     */

    function Router(routes1) {
      this.routes = routes1 != null ? routes1 : {};
      Tweak.History.addEvent('changed', this.__urlChanged, this);
    }


    /*
      Add a route to the Router.
      @param [String] event The event name to add route to.
      @param [String, Reg-ex] route A string or Reg-ex formatted string or Reg-ex.
    
      @example Adding a single string formatted route to an event.
        var router;
        router = new tweak.Router();
        router.add('navigation', '/:section/:page');
    
      @example Adding a single Reg-ex formatted route to an event.
        var router;
        router = new tweak.Router();
        router.add('navigation', /^(*.)$/);
     */

    Router.prototype.add = function(event, route) {
      if (this.routes[event] != null) {
        this.routes[event].push(route);
      } else {
        this.routes[event] = [route];
      }
    };


    /*
      @overload remove(event, route)
        Remove a single string formatted route from an event.
        @param [String] event The event name to add route to.
        @param [String] route A string formatted string. (':section/:page')
    
      @overload remove(event, route)
        Remove a string containing multiple string formatted routes from an event.
        @param [String] event The event name to add route to.
        @param [String] route A string containing multiple string formatted routes. (':section/:page :section/:page/*')
    
      @overload remove(event, route)
        Remove a single Reg-ex formatted route from an event.
        @param [String] event The event name to add route to.
        @param [Boolean] route A Reg-ex formatted route. (/^.*$/)
      
      @example Removing a single string formatted route from an event
        var router;
        router = new tweak.Router();
        router.remove('navigation', '/:section/:page');
    
      @example Removing a multiple string formatted routes from an event.
        var router;
        router = new tweak.Router();
        router.remove('navigation', '/:section/:page /:website/:section/?page');
    
      @example Removing a single Reg-ex formatted route from an event.
        var router;
        router = new tweak.Router();
        router.remove('navigation', /^(*.)$/);
     */

    Router.prototype.remove = function(event, routes) {
      var j, key, len, ref, route, routers;
      routers = this.routes[event];
      if (typeof routes === 'string') {
        ref = (" " + (routes.replace(/\s+/g, ' ')) + " ").split(' ');
        for (j = 0, len = ref.length; j < len; j++) {
          route = ref[j];
          routers = (" " + (routers.join(' ')) + " ").split(" " + route + " ");
        }
      } else {
        for (key in routers) {
          route = routers[key];
          if (route === routes) {
            delete routers[key];
          }
        }
      }
      this.routes[event] = routers;
      if ((routers != null) && ((routes == null) || routers.length === 0)) {
        delete this.routes[event];
      }
    };


    /*
      @private
      Reg-ex to get parameters from a URL.
     */

    __paramReg = /\/?[?:]([^?\/:]*)/g;


    /*
      @private
      Checks URL segment to see if it can extract additional data when formatted like a query string.
      @param [String] segment The URL segment to extract additional data when formatted as a query string.
      @return [Object, String] Extracted data of given segment parameter.
     */

    __getQueryData = function(segment) {
      var j, key, len, option, params, prop, props, query;
      query = /^.*\?(.+)/.exec(segment);
      if (query) {
        params = /([^&]+)&*/.exec(query[1]);
        if (params) {
          for (j = 0, len = params.length; j < len; j++) {
            option = params[j];
            segment = {};
            props = /(.+)[:=]+(.+)|(.+)/.exec(segment);
            if (props) {
              key = props[3] || props[1];
              prop = props[2] || 'true';
              segment[key] = prop;
            }
          }
        }
      } else if (segment) {
        segment = segment.replace(/\?/g, '');
      }
      return segment;
    };


    /*
      @private
      Converts a string formatted route into its Reg-ex counterpart.
      @param [String] route The route to convert into a Reg-ex formatted route.
      @return [Reg-ex] The Reg-ex formatted route of given string formatted route.
     */

    __toRegex = function(route) {
      var escapeReg, splatReg;
      escapeReg = /[\-\\\^\[\]\s{}+.,$|#]/g;
      splatReg = /\/?(\*)$/;
      route = route.replace(escapeReg, '\\$&');
      route = route.replace(__paramReg, function(match) {
        var res;
        res = '\\/?([^\\/]*?)';
        if (/^\/?\?/.exec(match)) {
          return "(?:" + res + ")?";
        } else {
          return res;
        }
      });
      route = route.replace(splatReg, '\\/?(.*?)');
      return new RegExp("^" + route + "[\\/\\s]?$");
    };


    /*
      @private
      Get the parameter keys from a string formatted route to use as the data passed to event.
      @param [String] route The string formatted route to get parameter keys from.
     */

    __getKeys = function(route) {
      var res;
      res = route.match(__paramReg) || [];
      res.push('splat');
      return res;
    };


    /*
      @private
      When history event is made this method is called to check this Routers events to see if any route events can be triggered.
      @param [String] url A URL to check route events to.
      @event {event_name} Triggers a route event with passed in data from URL.
     */

    Router.prototype.__urlChanged = function(url) {
      var event, item, key, keys, match, ref, res, results1, route, routes;
      url = url.replace(/^\/+|\/+$/g, '');
      ref = this.routes;
      results1 = [];
      for (event in ref) {
        routes = ref[event];
        results1.push((function() {
          var j, k, len, len1, ref1, results2;
          results2 = [];
          for (j = 0, len = routes.length; j < len; j++) {
            route = routes[j];
            keys = [];
            if (typeof route === 'string') {
              keys = __getKeys(route);
              route = __toRegex(route);
            }
            if (match = route.exec(url)) {
              res = {
                url: url,
                data: {}
              };
              match.splice(0, 1);
              key = 0;
              for (k = 0, len1 = match.length; k < len1; k++) {
                item = match[k];
                res.data[((ref1 = keys[key]) != null ? ref1.replace(/^[?:\/]*/, '') : void 0) || key] = __getQueryData(item);
                key++;
              }
              results2.push(this.triggerEvent(event, res));
            } else {
              results2.push(void 0);
            }
          }
          return results2;
        }).call(this));
      }
      return results1;
    };

    return Router;

  })(Tweak.Events);

}).call(this);

//# sourceMappingURL=tweak.js.map
